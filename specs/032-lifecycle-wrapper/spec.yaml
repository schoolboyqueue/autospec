feature:
    branch: "032-lifecycle-wrapper"
    created: "2025-12-17"
    status: "Completed"
    completed_at: 2025-12-17T01:04:20Z
    input: "Implement lifecycle wrapper for CLI commands to eliminate notification boilerplate. Simple function wrapper that handles timing and notification dispatch - no event bus needed."
user_stories:
    - id: "US-001"
      title: "Command lifecycle automation"
      priority: "P1"
      as_a: "CLI command developer"
      i_want: "to wrap command execution in a lifecycle function that handles timing and notifications automatically"
      so_that: "I can write commands without duplicating 6-8 lines of notification boilerplate"
      why_this_priority: "Core value proposition - eliminates ~100 lines of duplicated code across 11 commands"
      independent_test: "Create a test command that uses lifecycle.Run() and verify notifications fire without manual notification code"
      acceptance_scenarios:
        - given: "a CLI command using lifecycle.Run() wrapper"
          when: "the command executes successfully"
          then: "OnCommandComplete is called with command name, success=true, and correct duration"
        - given: "a CLI command using lifecycle.Run() wrapper"
          when: "the command fails with an error"
          then: "OnCommandComplete is called with success=false and the error is returned"
    - id: "US-002"
      title: "Consistent notification behavior"
      priority: "P1"
      as_a: "CLI user"
      i_want: "all workflow commands to send completion notifications consistently"
      so_that: "I always know when a command finishes regardless of which command I ran"
      why_this_priority: "User-facing consistency is essential for good UX"
      independent_test: "Run each of the 11 commands and verify notification fires on completion"
      acceptance_scenarios:
        - given: "any of the 11 workflow commands"
          when: "the command completes (success or failure)"
          then: "a completion notification is triggered with appropriate success status"
        - given: "a slow command taking several minutes"
          when: "the command completes"
          then: "the notification includes accurate duration"
    - id: "US-003"
      title: "Migrate existing commands"
      priority: "P1"
      as_a: "codebase maintainer"
      i_want: "all 11 workflow commands to use the new lifecycle wrapper"
      so_that: "notification behavior is consistent and boilerplate is eliminated"
      why_this_priority: "Required to achieve the full benefit of the refactor"
      independent_test: "Run regression test verifying all commands use lifecycle wrapper"
      acceptance_scenarios:
        - given: "the specify command using lifecycle.Run()"
          when: "the command completes"
          then: "notification is triggered via the wrapper (not direct boilerplate)"
        - given: "all 11 commands migrated to lifecycle.Run()"
          when: "running regression test TestAllCommandsHaveNotificationSupport"
          then: "the test passes verifying lifecycle wrapper usage"
    - id: "US-004"
      title: "Context cancellation support"
      priority: "P2"
      as_a: "CLI user"
      i_want: "commands to handle cancellation gracefully"
      so_that: "I can interrupt long-running commands and still get a notification"
      why_this_priority: "Important for user experience but not core functionality"
      independent_test: "Start a command, cancel it with Ctrl+C, verify notification fires"
      acceptance_scenarios:
        - given: "a command running via lifecycle.RunWithContext()"
          when: "the context is cancelled"
          then: "the command returns context.Canceled and notification fires with success=false"
    - id: "US-005"
      title: "Stage-level lifecycle support"
      priority: "P2"
      as_a: "workflow system"
      i_want: "the executor to use a stage wrapper for consistent stage completion handling"
      so_that: "stage completion notifications follow the same pattern as command completion"
      why_this_priority: "Consistency across the codebase, but secondary to command-level refactor"
      independent_test: "Execute a stage via RunStage(), verify stage notification fires"
      acceptance_scenarios:
        - given: "executor completing a workflow stage via RunStage()"
          when: "the stage finishes"
          then: "OnStageComplete is called with stage name, success status, and duration"
requirements:
    functional:
        - id: "FR-001"
          description: "MUST create internal/lifecycle package with Run() function that wraps command execution"
          testable: true
          acceptance_criteria: "Run(name, fn) executes fn, tracks duration, calls notify.OnCommandComplete(), and returns fn's error"
        - id: "FR-002"
          description: "MUST support RunWithContext() for cancellation support"
          testable: true
          acceptance_criteria: "Cancelled context causes Run to return context.Canceled error and still trigger notification"
        - id: "FR-003"
          description: "MUST support RunStage() for executor stage wrapping"
          testable: true
          acceptance_criteria: "RunStage(name, fn) calls notify.OnStageComplete() with correct parameters"
        - id: "FR-004"
          description: "MUST accept a NotificationHandler interface to enable testing and flexibility"
          testable: true
          acceptance_criteria: "lifecycle functions accept handler interface; nil handler is safe (no-op)"
        - id: "FR-005"
          description: "MUST migrate all 11 CLI commands to use lifecycle.Run()"
          testable: true
          acceptance_criteria: "All commands pass existing tests and no longer contain notification boilerplate"
        - id: "FR-006"
          description: "MUST update executor to use lifecycle.RunStage() instead of direct notification calls"
          testable: true
          acceptance_criteria: "Executor uses RunStage(); direct OnStageComplete calls removed"
        - id: "FR-007"
          description: "MUST maintain backward compatibility - existing notification behavior unchanged"
          testable: true
          acceptance_criteria: "All existing notification tests pass; user-visible behavior identical"
        - id: "FR-008"
          description: "MUST update TestAllCommandsHaveNotificationSupport to verify lifecycle usage"
          testable: true
          acceptance_criteria: "Regression test passes and verifies commands use lifecycle wrapper"
        - id: "FR-009"
          description: "MUST pass all quality gates: make test, make fmt, make lint, and make build"
          testable: true
          acceptance_criteria: "All commands exit 0; no test failures, format changes, lint errors, or build failures"
    non_functional:
        - id: "NFR-001"
          category: "performance"
          description: "Lifecycle wrapper MUST NOT add measurable latency to command execution"
          measurable_target: "Wrapper overhead under 1ms; no allocations beyond the function call"
        - id: "NFR-002"
          category: "reliability"
          description: "Notification failures MUST NOT crash the application or prevent command completion"
          measurable_target: "Handler panics are recovered; command result returned regardless of notification status"
        - id: "NFR-003"
          category: "code_quality"
          description: "All functions must be under 40 lines; extract helpers for complex logic"
          measurable_target: "No function exceeds 40 lines excluding comments"
        - id: "NFR-004"
          category: "code_quality"
          description: "All errors must be wrapped with context using fmt.Errorf(\"doing X: %w\", err)"
          measurable_target: "Zero bare 'return err' statements in new code"
        - id: "NFR-005"
          category: "code_quality"
          description: "Tests must use map-based table-driven pattern with t.Parallel()"
          measurable_target: "All new test functions use map[string]struct pattern and call t.Parallel()"
        - id: "NFR-006"
          category: "code_quality"
          description: "Accept interfaces, return concrete types"
          measurable_target: "Function signatures follow interface-in, concrete-out pattern where applicable"
        - id: "NFR-007"
          category: "simplicity"
          description: "Solution MUST NOT introduce external dependencies"
          measurable_target: "Zero new entries in go.mod; pure Go standard library solution"
        - id: "NFR-008"
          category: "simplicity"
          description: "Notifications MUST be synchronous to ensure they fire before process exit"
          measurable_target: "No goroutines spawned for notification dispatch"
success_criteria:
    measurable_outcomes:
        - id: "SC-001"
          description: "Notification boilerplate eliminated from all CLI commands"
          metric: "Lines of duplicated code removed"
          target: "~100 lines removed; each command's RunE function reduced by 6-8 lines"
        - id: "SC-002"
          description: "All 11 workflow commands use lifecycle wrapper"
          metric: "Commands migrated"
          target: "11 of 11 commands using lifecycle.Run()"
        - id: "SC-003"
          description: "Zero external dependencies added"
          metric: "New go.mod entries"
          target: "0 new dependencies"
        - id: "SC-004"
          description: "Notification behavior unchanged for users"
          metric: "User-visible behavior changes"
          target: "Zero changes to when/how notifications appear"
        - id: "SC-005"
          description: "All quality gates pass"
          metric: "CI pipeline status"
          target: "make test, make fmt, make lint, make build all exit 0"
key_entities:
    - name: "NotificationHandler"
      description: "Interface for receiving lifecycle notifications (already exists in internal/notify)"
      attributes:
        - "OnCommandComplete(name string, success bool, duration time.Duration)"
        - "OnStageComplete(name string, success bool, duration time.Duration)"
    - name: "Lifecycle Functions"
      description: "Simple wrapper functions in internal/lifecycle package"
      attributes:
        - "Run(handler, name, fn) error - wraps command execution"
        - "RunWithContext(ctx, handler, name, fn) error - cancellation-aware"
        - "RunStage(handler, name, fn) error - wraps stage execution"
edge_cases:
    - scenario: "Handler is nil"
      expected_behavior: "Wrapper executes fn normally; no notification sent; no panic"
    - scenario: "Handler panics during OnCommandComplete"
      expected_behavior: "Panic is recovered; command's original error (or nil) is still returned"
    - scenario: "fn panics during execution"
      expected_behavior: "Panic propagates (not caught by wrapper); notification NOT sent for panics"
    - scenario: "Context already cancelled before RunWithContext called"
      expected_behavior: "fn is not called; returns context.Canceled immediately; notification sent with success=false"
    - scenario: "Very fast command (sub-millisecond)"
      expected_behavior: "Duration accurately reflects actual time; notification sent normally"
    - scenario: "Process receives SIGTERM during command execution"
      expected_behavior: "Synchronous notification fires before process exits (no async goroutine race)"
assumptions:
    - "The existing notification handler interface (internal/notify) is sufficient and does not need modification"
    - "Commands are executed sequentially per user session (no need for concurrent lifecycle tracking)"
    - "The 11 commands listed in CLAUDE.md are the complete set requiring migration"
    - "Synchronous notification dispatch is acceptable (no need for async fire-and-forget)"
    - "A nil handler check is sufficient for testing; no need for mock/stub injection framework"
constraints:
    - "Must maintain backward compatibility - existing notification behavior unchanged from user perspective"
    - "Must not add external dependencies - pure Go standard library only"
    - "Must not break existing tests - all current tests must continue to pass"
    - "Must follow project coding standards (40-line functions, error wrapping, table-driven tests)"
    - "Notifications must be synchronous to guarantee delivery before process exit"
out_of_scope:
    - "Event bus or publish/subscribe architecture"
    - "Async notification dispatch"
    - "Multiple notification subscribers"
    - "Goroutine-based concurrent notification handling"
    - "External dependencies (kelindar/event or similar)"
    - "Event filtering or transformation"
    - "Metrics, logging, or telemetry integration"
    - "Distributed or remote notifications"
_meta:
    version: "1.0.0"
    generator: "autospec"
    generator_version: "autospec dev"
    created: "2025-12-17T00:31:23Z"
    artifact_type: "spec"
