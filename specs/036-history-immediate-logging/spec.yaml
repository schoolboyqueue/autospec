feature:
  branch: "036-history-immediate-logging"
  created: "2025-12-17"
  status: "Draft"
  input: "Improve history logging to write entries immediately when commands start and update them on completion. Current implementation only writes history AFTER command completion - crashes/interrupts lose the record entirely, no visibility into running commands, no unique identifier to track entries."

user_stories:
  - id: "US-001"
    title: "Track running commands in history"
    priority: "P1"
    as_a: "developer using autospec"
    i_want: "history entries written immediately when commands start"
    so_that: "I can see which commands are currently running and never lose history data due to crashes"
    why_this_priority: "Core functionality - prevents data loss and enables visibility into active work"
    independent_test: "Start a command and verify history entry exists before completion"
    acceptance_scenarios:
      - given: "No commands are running"
        when: "I start an autospec command (plan, specify, implement, etc.)"
        then: "A history entry is immediately written with status 'running'"
      - given: "A command is running with a history entry"
        when: "The process crashes or is interrupted"
        then: "The history entry remains with status 'running' showing the incomplete command"
      - given: "A command is running"
        when: "I check history from another terminal"
        then: "I see the in-progress command with 'running' status"

  - id: "US-002"
    title: "Complete history entries on command finish"
    priority: "P1"
    as_a: "developer using autospec"
    i_want: "history entries updated when commands complete"
    so_that: "I have accurate records of command outcomes including duration and exit status"
    why_this_priority: "Core functionality - completes the start/complete lifecycle"
    independent_test: "Run a command to completion and verify entry is updated with final status"
    acceptance_scenarios:
      - given: "A command is running with status 'running'"
        when: "The command completes successfully"
        then: "The entry is updated with status 'completed', exit code 0, completion time, and duration"
      - given: "A command is running with status 'running'"
        when: "The command fails with an error"
        then: "The entry is updated with status 'failed', non-zero exit code, completion time, and duration"
      - given: "A command is running with status 'running'"
        when: "The command is cancelled by the user (Ctrl+C)"
        then: "The entry is updated with status 'cancelled', completion time, and duration"

  - id: "US-003"
    title: "Memorable unique identifiers for history entries"
    priority: "P1"
    as_a: "developer using autospec"
    i_want: "each history entry to have a memorable unique identifier"
    so_that: "I can easily reference and discuss specific command executions"
    why_this_priority: "Enables tracking and correlation of entries across start and complete phases"
    independent_test: "Generate multiple IDs and verify format and uniqueness"
    acceptance_scenarios:
      - given: "A new command is started"
        when: "The history entry is created"
        then: "It receives a unique ID in format adjective_noun_YYYYMMDD_HHMMSS (e.g., brave_fox_20251216_180816)"
      - given: "Multiple commands are started in rapid succession"
        when: "IDs are generated within the same second"
        then: "Each ID is unique (different word combinations prevent collisions)"

  - id: "US-004"
    title: "View and filter history by status"
    priority: "P2"
    as_a: "developer using autospec"
    i_want: "to view history entries with their status and filter by status"
    so_that: "I can quickly see running commands or investigate failed ones"
    why_this_priority: "Improves usability of the history feature but not blocking for core functionality"
    independent_test: "Run commands with different outcomes, then filter history by status"
    acceptance_scenarios:
      - given: "History contains entries with various statuses"
        when: "I run the history command"
        then: "I see a status column with color-coded values (green=completed, yellow=running, red=failed)"
      - given: "History contains entries with various statuses"
        when: "I run the history command with --status running"
        then: "I see only entries with status 'running'"
      - given: "History contains entries with various statuses"
        when: "I run the history command with --status failed"
        then: "I see only entries with status 'failed'"

requirements:
  functional:
    - id: "FR-001"
      description: "MUST generate unique IDs using adjective_noun_YYYYMMDD_HHMMSS format"
      testable: true
      acceptance_criteria: "IDs follow the pattern with valid words and timestamp, no duplicates in testing"
    - id: "FR-002"
      description: "MUST write history entry with status 'running' immediately when command starts"
      testable: true
      acceptance_criteria: "Entry exists in history file before command logic executes"
    - id: "FR-003"
      description: "MUST update history entry with final status when command completes"
      testable: true
      acceptance_criteria: "Entry shows completed/failed/cancelled status, exit code, completion time, and duration"
    - id: "FR-004"
      description: "MUST preserve running entries when process crashes or is interrupted"
      testable: true
      acceptance_criteria: "Simulated crash leaves entry with 'running' status intact"
    - id: "FR-005"
      description: "MUST display status column in history output with color coding"
      testable: true
      acceptance_criteria: "History output shows status with appropriate colors"
    - id: "FR-006"
      description: "SHOULD support filtering history by status via --status flag"
      testable: true
      acceptance_criteria: "Flag filters output to show only matching statuses"
    - id: "FR-007"
      description: "MUST maintain backward compatibility with existing history format"
      testable: true
      acceptance_criteria: "Old entries without ID/status fields are readable and displayed"
    - id: "FR-008"
      description: "MUST pass all quality gates: make test, make fmt, make lint, and make build"
      testable: true
      acceptance_criteria: "All commands exit 0; no test failures, format changes, lint errors, or build failures"

  non_functional:
    - id: "NFR-001"
      category: "performance"
      description: "History file writes must not significantly delay command startup"
      measurable_target: "Less than 50ms added latency for writing initial entry"
    - id: "NFR-002"
      category: "reliability"
      description: "History entries must persist through process interruption"
      measurable_target: "100% of started commands have history entries after SIGINT/SIGTERM"
    - id: "NFR-003"
      category: "code_quality"
      description: "All functions must be under 40 lines; extract helpers for complex logic"
      measurable_target: "No function exceeds 40 lines excluding comments"
    - id: "NFR-004"
      category: "code_quality"
      description: "All errors must be wrapped with context using fmt.Errorf(\"doing X: %w\", err)"
      measurable_target: "Zero bare 'return err' statements in new code"
    - id: "NFR-005"
      category: "code_quality"
      description: "Tests must use map-based table-driven pattern with t.Parallel()"
      measurable_target: "All new test functions use map[string]struct pattern and call t.Parallel()"
    - id: "NFR-006"
      category: "code_quality"
      description: "Accept interfaces, return concrete types"
      measurable_target: "Function signatures follow interface-in, concrete-out pattern where applicable"

success_criteria:
  measurable_outcomes:
    - id: "SC-001"
      description: "All autospec commands create history entries immediately on start"
      metric: "Percentage of commands with immediate history entry"
      target: "100%"
    - id: "SC-002"
      description: "No history data loss during crashes or interruptions"
      metric: "Percentage of started commands with recoverable history entries after crash"
      target: "100%"
    - id: "SC-003"
      description: "Users can identify running commands from history output"
      metric: "Running commands visible in history with distinct status indicator"
      target: "100% of running commands shown with 'running' status"
    - id: "SC-004"
      description: "History IDs are memorable and unique"
      metric: "ID format follows adjective_noun_timestamp pattern with no collisions"
      target: "Zero duplicate IDs across all test scenarios"

key_entities:
  - name: "HistoryEntry"
    description: "A record of a single command execution in the history"
    attributes:
      - "id: unique identifier (adjective_noun_YYYYMMDD_HHMMSS)"
      - "command: the autospec command name (plan, specify, implement, etc.)"
      - "spec: the spec/branch name being operated on"
      - "status: current state (running, completed, failed, cancelled)"
      - "created_at: timestamp when command started"
      - "completed_at: timestamp when command finished (null if still running)"
      - "exit_code: process exit code (null if still running)"
      - "duration: computed time between start and completion"

  - name: "WordList"
    description: "Collections of words used for generating memorable IDs"
    attributes:
      - "adjectives: list of ~50 descriptive words (brave, calm, swift, etc.)"
      - "nouns: list of ~50 concrete nouns (fox, river, falcon, etc.)"

edge_cases:
  - scenario: "Multiple commands started in the same second"
    expected_behavior: "Different word combinations ensure unique IDs despite identical timestamps"
  - scenario: "History file is corrupted or unreadable"
    expected_behavior: "New entry is still written, error logged, existing data preserved if possible"
  - scenario: "Process receives SIGKILL (cannot be caught)"
    expected_behavior: "Entry remains with 'running' status since no cleanup is possible"
  - scenario: "Command completes but history file write fails"
    expected_behavior: "Error logged, command still exits with appropriate code"
  - scenario: "Old history entries without new fields (ID, status)"
    expected_behavior: "Displayed with empty/default values, no crashes or errors"
  - scenario: "User filters by non-existent status"
    expected_behavior: "Empty result set returned, no error"

assumptions:
  - "History file is stored locally and accessible with write permissions"
  - "File locking is already handled by existing history writer"
  - "Word lists of ~50 words each provide sufficient uniqueness for practical use"
  - "Timestamps use local timezone consistent with existing history behavior"
  - "YAML format is maintained for history file storage"

constraints:
  - "Must integrate with existing lifecycle wrapper pattern in internal/lifecycle/"
  - "Must not break existing history command functionality"
  - "Must work with existing HistoryLogger interface consumers"

out_of_scope:
  - "Remote/distributed history storage"
  - "History cleanup or rotation of old entries"
  - "Resuming interrupted commands"
  - "Real-time push notifications for command completion"
  - "History search by keyword or date range"
  - "Export history to external formats"

_meta:
  version: "1.0.0"
  generator: "autospec"
  generator_version: "autospec dev"
  created: "2025-12-17T02:18:14Z"
  artifact_type: "spec"
