// Package workflow provides workflow orchestration for autospec.
package workflow

import (
	"fmt"
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
)

// PhaseContext bundles all context needed for a single phase execution.
// This eliminates the need for Claude to read spec.yaml, plan.yaml, and tasks.yaml
// separately at the start of each phase session.

// ContextMeta provides machine-readable metadata signaling which artifacts are
// bundled in a phase context file. Claude agents use this to avoid redundant
// file reads that waste tokens.
type ContextMeta struct {
	// PhaseArtifactsBundled indicates spec, plan, tasks are bundled in this file
	PhaseArtifactsBundled bool `yaml:"phase_artifacts_bundled"`
	// BundledArtifacts lists the bundled artifact names for reference
	BundledArtifacts []string `yaml:"bundled_artifacts"`
	// HasChecklists indicates whether checklists/ directory exists under spec dir
	HasChecklists bool `yaml:"has_checklists"`
	// SkipReads lists file paths that should not be read separately
	SkipReads []string `yaml:"skip_reads"`
}

type PhaseContext struct {
	// ContextMeta provides metadata about bundled artifacts to avoid redundant reads
	ContextMeta ContextMeta `yaml:"_context_meta"`
	// Phase is the current phase number (1-based)
	Phase int `yaml:"phase"`
	// TotalPhases is the total number of phases in tasks.yaml
	TotalPhases int `yaml:"total_phases"`
	// SpecDir is the path to the spec directory
	SpecDir string `yaml:"spec_dir"`
	// Spec contains the full spec.yaml content
	Spec map[string]interface{} `yaml:"spec"`
	// Plan contains the full plan.yaml content
	Plan map[string]interface{} `yaml:"plan"`
	// Tasks contains only the tasks for this phase
	Tasks []map[string]interface{} `yaml:"tasks"`
}

// contextFileHeader is the header comment for context files
const contextFileHeader = `# Auto-generated phase context file
# This file bundles spec, plan, and phase-specific tasks for Claude
# DO NOT edit this file manually - it is regenerated for each phase execution
# File will be automatically cleaned up after phase execution

`

// GetContextFilePath returns the path for a phase context file.
// It creates the .autospec/context/ directory if missing.
// Falls back to os.TempDir() if .autospec/ is not writable.
func GetContextFilePath(phaseNumber int) (string, error) {
	// Try .autospec/context/ directory first
	contextDir := filepath.Join(".autospec", "context")

	// Create directory if it doesn't exist
	if err := os.MkdirAll(contextDir, 0755); err != nil {
		// Fall back to temp directory
		contextDir = os.TempDir()
		fmt.Fprintf(os.Stderr, "Warning: could not create .autospec/context/, using %s\n", contextDir)
	}

	filename := fmt.Sprintf("phase-%d.yaml", phaseNumber)
	return filepath.Join(contextDir, filename), nil
}

// EnsureContextDirGitignored checks if .autospec/context/ is in .gitignore
// and warns if not. It does not modify .gitignore automatically.
// It also recognizes parent directory patterns (e.g., .autospec/) that would
// implicitly cover the context directory.
func EnsureContextDirGitignored() {
	gitignorePath := ".gitignore"

	content, err := os.ReadFile(gitignorePath)
	if err != nil {
		// No .gitignore file - warn user
		fmt.Fprintf(os.Stderr, "Warning: .gitignore not found. Consider adding '.autospec/context/' to prevent accidental commits\n")
		return
	}

	// Check if pattern is already present - includes both specific patterns
	// and parent directory patterns that would cover the context directory
	patterns := []string{
		// Specific context patterns
		".autospec/context/",
		".autospec/context",
		".autospec/**/context",
		// Parent directory patterns that implicitly cover context/
		".autospec/",
		".autospec",
		".autospec/*",
	}
	contentStr := string(content)
	for _, pattern := range patterns {
		if containsLine(contentStr, pattern) {
			return // Already gitignored (directly or via parent)
		}
	}

	fmt.Fprintf(os.Stderr, "Warning: '.autospec/context/' not found in .gitignore. Consider adding it to prevent accidental commits\n")
}

// containsLine checks if a file content contains a specific line
func containsLine(content, line string) bool {
	lines := splitLines(content)
	for _, l := range lines {
		if l == line {
			return true
		}
	}
	return false
}

// splitLines splits content into lines
func splitLines(content string) []string {
	var lines []string
	var current string
	for _, r := range content {
		if r == '\n' {
			lines = append(lines, current)
			current = ""
		} else {
			current += string(r)
		}
	}
	if current != "" {
		lines = append(lines, current)
	}
	return lines
}

// checkChecklistsExist checks if the checklists/ directory exists under specDir.
// Returns true only if checklists/ exists and is a directory (not a file).
// Uses os.Stat for sub-millisecond performance (<1ms).
func checkChecklistsExist(specDir string) bool {
	checklistsPath := filepath.Join(specDir, "checklists")
	info, err := os.Stat(checklistsPath)
	if err != nil {
		return false // Directory does not exist or error accessing it
	}
	return info.IsDir()
}

// buildContextMeta creates ContextMeta signaling that artifacts are bundled.
// This allows Claude agents to avoid redundant file reads.
func buildContextMeta(specDir string) ContextMeta {
	return ContextMeta{
		PhaseArtifactsBundled: true,
		BundledArtifacts: []string{
			"spec.yaml",
			"plan.yaml",
			"tasks.yaml (phase-filtered)",
		},
		HasChecklists: checkChecklistsExist(specDir),
		SkipReads: []string{
			filepath.Join(specDir, "spec.yaml"),
			filepath.Join(specDir, "plan.yaml"),
			filepath.Join(specDir, "tasks.yaml"),
		},
	}
}

// BuildPhaseContext creates a PhaseContext from spec, plan, and tasks files.
// It reads spec.yaml and plan.yaml in full, but only includes tasks for the specified phase.
// It also populates ContextMeta to signal that artifacts are bundled.
func BuildPhaseContext(specDir string, phaseNumber int, totalPhases int) (*PhaseContext, error) {
	ctx := &PhaseContext{
		ContextMeta: buildContextMeta(specDir),
		Phase:       phaseNumber,
		TotalPhases: totalPhases,
		SpecDir:     specDir,
	}

	if err := loadSpecIntoContext(specDir, ctx); err != nil {
		return nil, err
	}
	if err := loadPlanIntoContext(specDir, ctx); err != nil {
		return nil, err
	}
	if err := loadPhaseTasksIntoContext(specDir, phaseNumber, ctx); err != nil {
		return nil, err
	}

	return ctx, nil
}

// loadSpecIntoContext reads spec.yaml and populates ctx.Spec
func loadSpecIntoContext(specDir string, ctx *PhaseContext) error {
	specPath := filepath.Join(specDir, "spec.yaml")
	specData, err := os.ReadFile(specPath)
	if err != nil {
		return fmt.Errorf("failed to read spec.yaml: %w", err)
	}
	if err := yaml.Unmarshal(specData, &ctx.Spec); err != nil {
		return fmt.Errorf("failed to parse spec.yaml: %w", err)
	}
	return nil
}

// loadPlanIntoContext reads plan.yaml and populates ctx.Plan
func loadPlanIntoContext(specDir string, ctx *PhaseContext) error {
	planPath := filepath.Join(specDir, "plan.yaml")
	planData, err := os.ReadFile(planPath)
	if err != nil {
		return fmt.Errorf("failed to read plan.yaml: %w", err)
	}
	if err := yaml.Unmarshal(planData, &ctx.Plan); err != nil {
		return fmt.Errorf("failed to parse plan.yaml: %w", err)
	}
	return nil
}

// loadPhaseTasksIntoContext reads tasks.yaml and extracts tasks for the specified phase
func loadPhaseTasksIntoContext(specDir string, phaseNumber int, ctx *PhaseContext) error {
	tasksPath := filepath.Join(specDir, "tasks.yaml")
	tasksData, err := os.ReadFile(tasksPath)
	if err != nil {
		return fmt.Errorf("failed to read tasks.yaml: %w", err)
	}

	var tasksFile map[string]interface{}
	if err := yaml.Unmarshal(tasksData, &tasksFile); err != nil {
		return fmt.Errorf("failed to parse tasks.yaml: %w", err)
	}

	phaseTasks, err := extractTasksForPhase(tasksFile, phaseNumber)
	if err != nil {
		return fmt.Errorf("failed to extract tasks for phase %d: %w", phaseNumber, err)
	}
	ctx.Tasks = phaseTasks
	return nil
}

// extractTasksForPhase extracts tasks for a specific phase from parsed tasks.yaml
func extractTasksForPhase(tasksFile map[string]interface{}, phaseNumber int) ([]map[string]interface{}, error) {
	phases, ok := tasksFile["phases"].([]interface{})
	if !ok {
		return nil, fmt.Errorf("phases field not found or invalid in tasks.yaml")
	}

	for _, p := range phases {
		phase, ok := p.(map[string]interface{})
		if !ok {
			continue
		}

		num, ok := phase["number"].(int)
		if !ok {
			// Try float64 (YAML sometimes parses integers as float64)
			if numFloat, ok := phase["number"].(float64); ok {
				num = int(numFloat)
			} else {
				continue
			}
		}

		if num == phaseNumber {
			tasks, ok := phase["tasks"].([]interface{})
			if !ok {
				return []map[string]interface{}{}, nil // Empty phase
			}

			result := make([]map[string]interface{}, 0, len(tasks))
			for _, t := range tasks {
				if task, ok := t.(map[string]interface{}); ok {
					result = append(result, task)
				}
			}
			return result, nil
		}
	}

	return nil, fmt.Errorf("phase %d not found in tasks.yaml", phaseNumber)
}

// WriteContextFile serializes a PhaseContext to a YAML file.
// Returns the path to the created file.
func WriteContextFile(ctx *PhaseContext) (string, error) {
	path, err := GetContextFilePath(ctx.Phase)
	if err != nil {
		return "", fmt.Errorf("failed to get context file path: %w", err)
	}

	// Serialize to YAML
	data, err := yaml.Marshal(ctx)
	if err != nil {
		return "", fmt.Errorf("failed to serialize context: %w", err)
	}

	// Write with header comment
	content := contextFileHeader + string(data)
	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return "", fmt.Errorf("failed to write context file: %w", err)
	}

	return path, nil
}

// CleanupContextFile removes a context file at the specified path.
// Returns nil if file doesn't exist (idempotent).
func CleanupContextFile(path string) error {
	err := os.Remove(path)
	if err != nil && !os.IsNotExist(err) {
		fmt.Fprintf(os.Stderr, "Warning: failed to clean up context file %s: %v\n", path, err)
		return fmt.Errorf("removing context file %s: %w", path, err)
	}
	return nil
}
